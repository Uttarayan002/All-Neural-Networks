# -*- coding: utf-8 -*-
"""RNN

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KaiUTVscD9H0QHH-3sxatd0Pq74P3QVd

# Simple RNN Implementation Using Keras/TensorFlow
Practical implementation of a Recurrent Neural Network using Keras (TensorFlow's high-level API)
"""

import numpy as np
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import SimpleRNN, Dense
import matplotlib.pyplot as plt

def generate_sequence_data(n_samples=1000, seq_length=20):
    """Generate simple sequential data for practice"""
    X = np.zeros((n_samples, seq_length, 1))
    y = np.zeros((n_samples, 1))

    for i in range(n_samples):
        start_val = np.random.uniform(0, 0.5)
        for t in range(seq_length):
            X[i,t,0] = start_val + t*0.1  # Simple increasing sequence
        y[i,0] = np.sin(X[i,-1,0])  # Predict sin of last value

    return X, y

# Generate data
from sklearn.model_selection import train_test_split

X, y = generate_sequence_data()
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)

# SimpleRNN layer with 32 units (hidden states)
# return_sequences=False means we only get last output

model = Sequential([
    SimpleRNN(32, input_shape=(X.shape[1], X.shape[2]), activation='tanh'),

    Dense(1)])   # Fully connected output layerDense(1)])

model.compile(optimizer='adam', loss='mse', metrics=['mae'])
model.summary()

history = model.fit(X_train, y_train, epochs=50, batch_size=32,
    validation_data=(X_test, y_test), verbose=1)

# Plot training history
plt.figure(figsize=(12, 4))
plt.subplot(1, 2, 1)
plt.plot(history.history['loss'], label='Train Loss')
plt.plot(history.history['val_loss'], label='Test Loss')
plt.legend()
plt.title('Loss Over Epochs')

plt.subplot(1, 2, 2)
plt.plot(history.history['mae'], label='Train MAE')
plt.plot(history.history['val_mae'], label='Test MAE')
plt.legend()
plt.title('Accuracy Over Epochs')
plt.show()

# Make predictions
sample_idx = 0
sample_input = X_test[sample_idx]
sample_true = y_test[sample_idx]
sample_pred = model.predict(sample_input[np.newaxis, ...])[0,0]

print(f"\nSample Prediction:")
print(f"Input sequence (last value): {sample_input[-1,0]:.4f}")
print(f"True output: {sample_true[0]:.4f}")
print(f"Predicted output: {sample_pred:.4f}")
print(f"Error: {abs(sample_true[0]-sample_pred):.4f}")

